\documentclass[letterpaper, 10 pt, conference]{ieeeconf}
\usepackage{cite}

\title{\LARGE \bf
Analyzing Peripheral Interupts for Use in Embedded System Emulation
}

\author{Fernando Maymi and Casey McGinley}


\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\begin{abstract}
The state of security for embedded systems is . Emulation of embedded systems, however, is severly limited. We take a first step towards true emulation of an embedded system by using symbolic execution to identify the peripheral interupts of Econotag, a very simple embedded system.
\end{abstract}

\section{Introduction}


\section{Method}

\section{Conclusion}
\subsection{Results}
\subsection{Limitation and Future Work}
-Needs vector table value and address in advance
-Generalize to arbitrary binary

\section{Related work}
There are several studies in the current literature which outline the insufficient security on embedded systems. For example, in 2014 a French research group used basic symbolic execution techniques to discover 38 new vulnerabilities in 693 firmware samples \cite{acostin}. Additionally, in 2013 a research group at Columbia demonstrated a general purpose methodology for leveraging vulnerable firmware update mechanisms on many embedded devices \cite{acui}. As such, there is need for new and effective methods to analyze firmware images dynamically. We believe our tool represents one of the first steps towards an effective and generalized solution for emulating embedded devices, ultimately facilitating the dynamic analysis of embedded firmware images. Considering this larger goal, our work is just one small part, namely mapping interrupt numbers to the specific interrupt handlers that they trigger. In this very specific context, as far as we know, no previous work has attempted to solve the same problem. That said, there is a large body of existing research into the dynamic analysis of embedded devices and their overall security.

The classical way of dynamically analyzing an embedded device requires the firmware to be executed on the hardware itself, with a hardware debugger attached. JTAG \cite{jtag} is the standard developed by IEEE for these debuggers. Analyzing firmware images in this way is limited in several capacities. First of all, hardware debuggers are difficult to work with, and especially difficult to integrate into existing dynamic analysis platforms. Furthermore, when working with hardware debuggers, there is the possibility that your test and analyses might bring the device into an improper state, causing damage to the hardware itself. Finally, analyzing directly on hardware is an unscalable solution, as for every firmware image you want to analyze, you need a corresponding piece of hardware, which can get expensive and logistically problematic. 

One recently proposed alternative to hardware debuggers is Avatar \cite{avatar}, a dynamic analysis platform designed for firmware images. Avatar makes use of an existing general-purpose dynamic analysis platform known as S2E \cite{s2e} to emulate and analyze firmware images. In order to deal with the problem of poorly specified peripherals in embedded devices, Avatar forwards all attempted interactions with the peripherals in the S2E environment to the actual hardware. This hybrid solution facilitates the use of existing dynamic analyses on firmware images, but since the hardware is still used partially, Avatar is not a scalable solution and may cause damage to the hardware.

Given that, we believe whole system emulation of embedded devices to be the only viable solution. Unlike hardware debuggers or hybrid solutions, whole system emulation doesn’t suffer from problems of scale or potential hardware damage as the physical hardware is removed from the equation entirely. Additionally, in an emulated environment, everything is implemented as software, meaning that anything can be modified or edited, allowing for easy instrumentation and dynamic analysis of firmware images. This will allow us to leverage powerful existing dynamic analysis platforms like PANDA \cite{panda}, which allows users to record and replay execution traces so that dynamic analysis can be performed out of sync with the execution itself, an idea first proposed by Chow et. al. at VMware \cite{jchow}. PANDA’s dynamic analyses are built on top of QEMU \cite{qemu}, an open-source emulation platform supporting many different CPU architectures. 

Now that we’ve established where our research fits into the big picture (embedded device emulation and dynamic analysis), we consider the narrower scope of the specific work presented in this paper, namely, mapping interrupt numbers to interrupt handlers via symbolic execution. Symbolic execution \cite{jking} is a method of analyzing a program by executing on symbolic values, values which represent valid ranges or conditions. In contrast, concrete execution is “business as usual,” executing a program on real or concrete inputs. Symbolic execution allows a user to determine parameters for inputs that result in code execution along a given path. This neatly aligns with our needs, as we need to determine what inputs (interrupt numbers) lead to execution of which interrupt handlers. In addition, although often used interchangeably with symbolic execution, concolic execution \cite{ksen} is actually a hybrid technique wherein concrete inputs identify a single execution trace which is then explored symbolically. 

We will be using the angr framework \cite{angr} for our analysis because of the general and under constrained symbolic execution options. Angr provides a wide array of analytical capabilities, from static to dynamic, and from purely symbolic to concolic. SimuVEX is angr’s symbolic execution engine, which tracks the program state using a python based wrapper \cite{pyvex} of the intermediate representation VEX \cite{vex}. The dynamic symbolic execution is based on the techniques described in Mayhem \cite{mayhem} which is more memory efficient than other options, allowing us to execute the firmware long enough for it to populate things like interrupt handlers which may not be present in memory until after boot. Angr supplements Mayhem with the veritesting static symbolic execution system \cite{veritesting} which reduces the execution space when multiple paths would have the same result. Another feature of angr that may be useful is called Under Constrained Symbolic Execution (UCSE) \cite{ucklee2}, which allows individual functions to be analyzed, though at the cost of increased false positives. This feature is implemented in angr as UC-angr, and it is based on a previous tool called UC-KLEE \cite{ucklee1}, which itself was a UCSE enhancement on top of the dynamic symbolic execution tool KLEE \cite{klee}.

\bibliography{references}{}
\bibliographystyle{plain}

\end{document}
