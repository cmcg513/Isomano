\documentclass[letterpaper, 10 pt, conference]{ieeeconf}
\usepackage{cite}

\title{\LARGE \bf
Analyzing Peripheral Interupts for Use in Embedded System Emulation
}

\author{Fernando Maymi and Casey McGinley}


\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\begin{abstract}
The state of security for embedded systems is decidedly lacking. Dynamic analysis can a powerful tool for improving this state but is limited by hardware requirements. We believe the solution is full system emulation and take a first step towards addressing this challenge with a tool that can map peripheral interrupt numbers to the interrupt handler that they trigger for the Redbee Econotag and a symbolic execution based approach that is likely applicable to more complicated systems.
\end{abstract}

\section{Introduction} %STUB
There are several studies in the current literature which outline the insufficient security of embedded systems. For example, in 2014 a French research group used basic symbolic execution techniques to discover 38 new vulnerabilities in 693 firmware samples \cite{acostin}. Additionally, in 2013 a research group at Columbia demonstrated a general purpose methodology for leveraging vulnerable firmware update mechanisms on many embedded devices \cite{acui}. As such, there is need for new and effective methods to analyze firmware images dynamically.

The classical way of dynamically analyzing an embedded device requires the firmware to be executed on the hardware itself, with a hardware debugger attached. Analyzing firmware images in this way is limited in several capacities. First of all, hardware debuggers are difficult to work with, and especially difficult to integrate into existing dynamic analysis platforms. Furthermore, when working with hardware debuggers, there is the possibility that your test and analyses might bring the device into an improper state, causing damage to the hardware itself. Finally, analyzing directly on hardware is an unscalable solution, as for every firmware image you want to analyze, you need a corresponding piece of hardware, which can get expensive and logistically problematic. Similarly, the hybrid solution Avatar \cite(avatar) facilitates the use of existing dynamic analyses on firmware images, but since the hardware is still used partially, it is not a scalable solution and may cause damage to the hardware.

Given that, we believe whole system emulation of embedded devices to be the only viable solution. Unlike hardware debuggers or hybrid solutions, whole system emulation doesn't suffer from problems of scale or potential hardware damage as the physical hardware is removed from the equation entirely. Additionally, in an emulated environment, everything is implemented as software, meaning that anything can be modified or edited, allowing for easy instrumentation and dynamic analysis of firmware images.

Considering this larger goal, our work is just one small part, namely mapping interrupt numbers to the specific interrupt handlers that they trigger. We believe our tool represents one of the first steps towards an effective and generalized solution for emulating embedded devices, ultimately facilitating the dynamic analysis of embedded firmware images.

\subsection{Econotag}
The Econotag is an open source and exceptionally simple example of an embedded system. It is built on MC13224v, an ARM7 micro-controller with an integrated radio. The fact that Econotag uses ARM poses a minor problem as there are a couple instruction that angr does not handle, fortunately it is easy to hook a function to those instruction, solving the problem. The Econotag has very few peripherals, making this a good device for testing our approach.

\section{Method}
Before symbolic execution can begin, there was some information and tweaking that needed to be done to get the symbolic execution to behave well. Because angr does not handle MRS/MSR instruction in ARM, it is necessary to hook in code to handle these instructions. These hooks and the location of the instructions were determined for us. Additionally we were provided with the vector table which was generated by running the firmware symbolically until interrupts were enabled. % Detail how this was determined
The vector table was then output and put in the correct address by our program. 

Once we have the environment set up, we symbolically execute until just before the interrupt handlers are called. Some firmware specific steps are needed here including manually entering constraints that angr misses and stepping to the exact location needed. Each possible interrupt number is then tested and paired with the address in the vector table that it calls.

\section{Conclusion}
%Do I need to put anything here? Is it unusual to have a section that immediately starts with a subsection?
\subsection{Results}
Our tool delivered as expected. There were three interrupt numbers with unique handlers, the rest were tied to what appears to be a general purpose interrupt handler. Additionally, the program is relatively quick. Our code finishes pretty consistently within 1.2 seconds. The prerequisite task of retrieving the vector table, however took over 15 minutes. 

\subsection{Limitations and Future Work}%Could probably beef up
In terms of both functionality and polish, there are a number of modifications that could be made to our tool. In its current state, our program only works with the Econotag (in part because there was a bit of jury rigging needed to make this work), however the method itself is completely general. In theory our tool could be extended to map peripheral interrupt handlers for any embedded system which could in turn be used as part of an emulation system. Of course, the ultimate goal for this tool is for it to support a wide variety of embedded systems without extra tweaking. 

Additionally some usability improvements are necessary to make the tool easier to use on a wider variety of embedded systems. In this vein, we could eliminate the need to know the vector table in advance by executing the firmware symbolically until interrupts are enabled and then proceeding with our current approach (skipping the step where we insert the vector table of course, its already there), however, it takes a considerable amount of time for the symbolic execution to reach the point where interrupts are enabled, adding significant overhead to the already slow program. One way to reduce this time is to store the vector table after it has been generated and insert it if it is available, this way the vector table would only have to be generated once.


\section{Related Work} %This section is looking a bit beat up after taking much of it for use in the intro. Need to rework
In the very specific context of our project, we know of no previous work attempting to solve the same problem. That said, there is a large body of existing research into the dynamic analysis of embedded devices and their overall security.

The most common JTAG \cite{jtag} is the standard developed by IEEE for hardware debuggers. One recently proposed alternative to hardware debuggers is Avatar \cite{avatar}, a dynamic analysis platform designed for firmware images. Avatar makes use of an existing general-purpose dynamic analysis platform known as S2E \cite{s2e} to emulate and analyze firmware images. In order to deal with the problem of poorly specified peripherals in embedded devices, Avatar forwards all attempted interactions with the peripherals in the S2E environment to the actual hardware. 

Whole system emulation of embedded systems will allow us to leverage powerful existing dynamic analysis platforms like PANDA \cite{panda}, which allows users to record and replay execution traces so that dynamic analysis can be performed out of sync with the execution itself, an idea first proposed by Chow et. al. at VMware \cite{jchow}. PANDA's dynamic analyses are built on top of QEMU \cite{qemu}, an open-source emulation platform supporting many different CPU architectures. 

Now that we've established where our research fits into the big picture (embedded device emulation and dynamic analysis), we consider the narrower scope of the specific work presented in this paper, namely, mapping interrupt numbers to interrupt handlers via symbolic execution. Symbolic execution \cite{jking} is a method of analyzing a program by executing on symbolic values, values which represent valid ranges or conditions. In contrast, concrete execution is 'business as usual', executing a program on real or concrete inputs. Symbolic execution allows a user to determine parameters for inputs that result in code execution along a given path. This neatly aligns with our needs, as we need to determine what inputs (interrupt numbers) lead to execution of which interrupt handlers. In addition, although often used interchangeably with symbolic execution, concolic execution \cite{ksen} is actually a hybrid technique wherein concrete inputs identify a single execution trace which is then explored symbolically. 

We will be using the angr framework \cite{angr} for our analysis because of the general and under constrained symbolic execution options. Angr provides a wide array of analytical capabilities, from static to dynamic, and from purely symbolic to concolic. SimuVEX is angr's symbolic execution engine, which tracks the program state using a python based wrapper \cite{pyvex} of the intermediate representation VEX \cite{vex}. The dynamic symbolic execution is based on the techniques described in Mayhem \cite{mayhem} which is more memory efficient than other options, allowing us to execute the firmware long enough for it to populate things like interrupt handlers which may not be present in memory until after boot. Angr supplements Mayhem with the veritesting static symbolic execution system \cite{veritesting} which reduces the execution space when multiple paths would have the same result. Another feature of angr that may be useful is called Under Constrained Symbolic Execution (UCSE) \cite{ucklee2}, which allows individual functions to be analyzed, though at the cost of increased false positives. This feature is implemented in angr as UC-angr, and it is based on a previous tool called UC-KLEE \cite{ucklee1}, which itself was a UCSE enhancement on top of the dynamic symbolic execution tool KLEE \cite{klee}.

\bibliography{references}{}
\bibliographystyle{plain}

\end{document}
